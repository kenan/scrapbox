# GitLab flowから学ぶワークフローの実践 | POSTD

- 参照元
https://postd.cc/gitlab-flow/

Gitでは複数のコミットを一つに圧縮して整理するために対話的なリベース（rebase –i）を利用できます。この機能は、開発中に小変更のためのいくつかのコミットを行なったあと単一のコミットに置き換えたいときや、より論理的に整理したいときに有用です。しかしながらリモートサーバへプッシュしたコミットを決してリベースすべきではありません。誰かがそのコミットを参照していたりcherry-pickしているかもしれません。リベースするとコミットの識別子（SHA-1）が変わり、これは混乱を生じます。もしそうなると、同じ変更が複数の識別子として識別されて、さらなる混乱を引き起こすかもしれません。もし人々があなたのコードをすでにレビューしていたら、全てを一つのコミットへリベースすると、それ以前にあなたが行なった改善のみを彼らがレビューすることは困難でしょう。

皆しばしばコミットしてリモートリポジトリへ頻繁にプッシュすることを奨励されているので、他の人々はあらゆる人が取り組んでいる内容を知っています。これは変更ごとに多数のコミットをもたらして、履歴の理解をより困難させます。しかし安定した識別子を持つことの利点はこの欠点に勝ります。また文脈で変更を理解することで、コードがmasterブランチにマージされるとき、全てのコミットを一緒にまとめるマージコミットを常に探せます。

複数のコミットをfeatureブランチからmasterブランチへマージすると、元に戻すことはより困難になります。もし全てのコミットを一つへ圧縮していたら、このコミットを単に取り消せるだけです。しかしすでに述べたようにプッシュしたあとでコミットをリベースすべきではありません。幸運にもマージの取り消しでしばらく前へ戻すことはGitで可能です。しかしながら、取り消したいコミットのための特定のマージコミットを持つことを要求します。マージを取り消した後に、考え直して戻したい場合、Gitはコードを再びマージすることを許可しないので、再びマージする代わりに取り消しを取り消してください。

マージを取り消せることは、”–no-ff”オプションを使って手動でマージするときに、常にマージコミットを作成するよい理由です。Gitの管理ソフトウェアは、あなたがMerge Requestを受け入れるとき、常にマージコミットを作成します。

masterブランチにコミットしたあとでそれらを整理するために、Gitでfeatureブランチのコミットをリベースすることもできます。これはmasterをまとめてfeatureブランチにして直線的で整った履歴を作成するときに、マージコミットの作成を防ぎます。しかしながら、ちょうど、コミットの圧縮のように、リモートサーバへプッシュしてきたコミットを決してリベースすべきではありません。そうすることでチームとすでに共有した進行中の作業はリベースできなくなります。これが私たちが推奨する方法です。featureブランチを更新し続けるためにリベースを使うとき、類似のコンフリクトを何度も解決する必要があります。ときとして記録された解決を再利用（rerere: reuse recorded resolutions）できますが、リベースをしなければ、一度のコンフリクトを解決するだけで準備は完了です。たくさんのマージコミットは避けるというのが良い方法であるべきでしょう。

*たくさんのマージコミットの作成を避ける方法は、masterをfeatureブランチへ頻繁にマージしないことです。*
ここでmasterへマージするための3つの理由を議論したいと思います。コードの活用、マージのコンフリクトの解決、および長期のブランチです。*もしfeatureブランチを作成したあとにmasterへ取り込まれたいくらかのコードを活用することが必要なら、ときとしてコミットをcherry-pickするだけでこれを解決できます。*